require 'rails_helper'

# # This spec was generated by rspec-rails when you ran the scaffold generator.
# # It demonstrates how one might use RSpec to specify the controller code that
# # was generated by Rails when you ran the scaffold generator.
# #
# # It assumes that the implementation code is generated by the rails scaffold
# # generator.  If you are using any extension libraries to generate different
# # controller code, this generated spec may or may not pass.
# #
# # It only uses APIs available in rails and/or rspec-rails.  There are a number
# # of tools you can use to make these specs even more expressive, but we're
# # sticking to rails and rspec-rails APIs to keep things simple and stable.
# #
# # Compared to earlier versions of this generator, there is very limited use of
# # stubs and message expectations in this spec.  Stubs are only used when there
# # is no simpler way to get a handle on the object needed for the example.
# # Message expectations are only used when there is no simpler way to specify
# # that an instance is receiving a specific message.
# #
# # Also compared to earlier versions of this generator, there are no longer any
# # expectations of assigns and templates rendered. These features have been
# # removed from Rails core in Rails 5, but can be added back in via the
# # `rails-controller-testing` gem.

RSpec.describe TimetablesController, type: :controller do
   before(:each) do  
     @user = User.create!(name: 'SUNY Tester', email: 'stester@binghamton.edu')
     @auth = Authorization.create!(provider: "github", uid: "123456", user_id: @user.id)
     session[:user_id] = @user.id
     @current_user = @user
   end 
		describe "index" do
		  before(:each) do
				 @time1 = Timetable.create(time_in:DateTime.new(2021,3,10),time_out:DateTime.new(2021,3,10),notes:"",user_id:"1")
				 @time2 = Timetable.create(time_in:DateTime.new(2021,4,11),time_out:DateTime.new(2021,4,11),notes:"",user_id:"1")
      end
		
     it "gathers all the timeables fromt the current user" do
			 get :index
			 expect(assigns[:timetables]).to eq(Timetable.where(:user_id => @user.id))
		 end
	
		it "renders the index template" do
      get :index
      expect(response).to render_template(:index)
    end
		 
		 it "shows the amount of shifts" do
			 get :index
			 expect(assigns[:total_days]).to eq(Timetable.where(:user_id => @user.id).size)
		 end
		 
		 
		 it "shows the number of hours" do
			 get :index
			 expect(assigns[:total_hours]).not_to eq(nil)
		 end
		 
		 it "filters the hours by date" do
			 get :index
			 expect(Timetable.where({:user_id => @user.id, time_in:DateTime.new(2021,3,10)..(DateTime.new(2021,3,30) + 1.day) }).size).to eq(1)
		 end
		 
	 end

	
	 describe "new" do
		 it "assigns a timetable model" do
			  get :new
			  expect(assigns[:timetable]).to be_instance_of(Timetable)
		 end
		 
		 it "sets the the time in" do
			 get :new
			 expect(assigns[:timetable].time_in).not_to eq(nil)
		 end
		 it "sets the flash message" do
			 get :new
			 expect(flash[:notice]).to eq("You have successfully clocked in!")
		 end
		 it "redirects back to the dashboard" do
			 get :new
			 expect(response).to redirect_to(timetables_path)
	   end
		 
	 end
	
	 describe "edit" do
		  let(:id1) {'1'}
      let(:time1) {instance_double('Timetable', time_in: "2021-04-20 05:20:48", time_out: "2021-04-20 05:20:48")}
		 
		  let(:id2) {'2'}
      let(:time2) {instance_double('Timetable', time_in: "2021-04-20 06:20:48", time_out: nil, notes:"", user_id:"1")}
		 
		  before(:each) do
        allow(Timetable).to receive(:find).with(id1).and_return(time1)
				allow(Timetable).to receive(:find).with(id2).and_return(time2)
				#@time1 = Timetable.create(time_in: "2021-04-20 06:20:48", time_out: nil)
      end
		 
			it "renders the edit template" do
				get :edit, :id=>id1
        expect(response).to render_template(:edit)		
			end	
		 
	 
		 it "updates the time out when timeout is nil" do
			 allow(time2).to receive(:update). and_return(time_out:DateTime.now())
			 get :edit, :id=>id2
		 end
		 
		 it "does not update the time out when timeout is not nil" do
			 expect(time1).not_to receive(:update)
			 get :edit, :id=>id1
			
			
		 end
		 
	end
	describe "create" do
		  context "with valid params" do
      it "creates a new Timetable" do
        expect {
          post :create, {:timetable => {time_in: ""}}
        }.to change(Timetable, :count).by(1)
      end

  
    end

	end
	
	describe "destroy" do
		let(:id1) {'1'}
    let(:time1) {instance_double('Timetable', time_in: "2021-04-20 05:20:48", time_out: "", notes: "N/A")}
		 before(:each) do
       @time1 = Timetable.create(time_in:"",time_out:"",notes:"",user_id:"")
      end
		
	  it "Deletes a timetable" do
		 @time1.destroy
     expect(Timetable.find_by(notes: "N/A")).to be_nil
	  end
	
	end
	
	describe "update" do
		before(:all) do
			@time1 = Timetable.create(time_in:"",time_out:"",notes:"",user_id:"")
			@time2 = Timetable.create(time_in:"",time_out:nil ,notes:"",user_id:"")
		end
		it "updates the timetable notes" do
			@time1.update(notes:"Updated!")
			expect(Timetable.find_by_notes("Updated!")).to eq(@time1)
		end
		
		it "updates when time out is nil" do 
			@time2.update(time_out:DateTime.now())
			expect(@time2.time_out).not_to eq(nil)
		end
		
	end
	
	
end